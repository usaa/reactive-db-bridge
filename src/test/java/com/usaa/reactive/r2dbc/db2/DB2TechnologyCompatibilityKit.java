package com.usaa.reactive.r2dbc.db2;

import com.usaa.reactive.r2dbc.sandbox.SandboxDB;
import com.zaxxer.hikari.HikariDataSource;
import io.r2dbc.spi.*;
import io.r2dbc.spi.test.TestKit;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.*;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.support.AbstractLobCreatingPreparedStatementCallback;
import org.springframework.jdbc.support.lob.DefaultLobHandler;
import org.springframework.jdbc.support.lob.LobCreator;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collection;
import java.util.function.Function;

@Slf4j
public class DB2TechnologyCompatibilityKit implements TestKit<Integer> {
    private static final SandboxDB DB = SandboxDB.getInstance();

    private static ConnectionFactory connectionFactory;
    private static JdbcOperations jdbcOperations;

    @BeforeAll
    public static void setup() throws SQLException {
        DB.startDB();

        HikariDataSource dataSource = DataSourceBuilder.create()
                .type(HikariDataSource.class)
                .url(DB.getJdbcUrl())
                .username(DB.getUsername())
                .password(DB.getPassword())
                .build();

        connectionFactory = ConnectionFactories.get(DB.getConnectionFactoryOptions());

        dataSource.setMaximumPoolSize(1);
        jdbcOperations = new JdbcTemplate(dataSource);

        log.debug("Dropping tables before all tests");
        SqlHelper.dropTables(dataSource);
    }

    @AfterAll
    public static void shutdown() {
        DB.stopDB();
    }

    @BeforeEach
    public void createTable() {
        log.debug("Creating tables before test");
        TestKit.super.createTable();
    }

    @AfterEach
    public void dropTable() {
        log.debug("Dropping tables after test");
        TestKit.super.dropTable();
    }

    @Override
    public ConnectionFactory getConnectionFactory() {
        return connectionFactory;
    }

    @Override
    public Integer getIdentifier(int index) {
        return index;
    }

    @Override
    public JdbcOperations getJdbcOperations() {
        return jdbcOperations;
    }

    @Override
    public String getPlaceholder(int index) {
        return "?";
    }

    /*
     * We choose not to support "compound statements", as that would require us to parse SQL, which is not something we
     * want to do in this pseudo-driver wrapper. We just let the underlying Vert.X implementation do all the SQL parsing
     *
     * Compound statements are in the TCK, but not mentioned in the Spec
     */
    @Override @Test @Disabled
    public void compoundStatement() {
        TestKit.super.compoundStatement();
    }

    // Case sensitivity will be fixed in the 0.9.0 spec/TCK
    @Test
    public void columnMetadata() {
        getJdbcOperations().execute(expand(TestStatement.INSERT_TWO_COLUMNS));

        Flux.usingWhen(getConnectionFactory().create(),
                connection -> Flux.from(connection

                        .createStatement(expand(TestStatement.SELECT_VALUE_TWO_COLUMNS))
                        .execute())
                        .flatMap(result -> result.map((row, rowMetadata) -> {
                            Collection<String> columnNames = rowMetadata.getColumnNames();
                            return Arrays.asList(
                                    rowMetadata.getColumnMetadata("value").getName(),
                                    rowMetadata.getColumnMetadata("VALUE").getName(),
                                    columnNames.contains("value"),
                                    columnNames.contains("VALUE"));
                        }))
                        .flatMapIterable(Function.identity()),
                Connection::close)
                .as(StepVerifier::create)
                // Make this case insensitive
                .expectNextMatches(s -> s instanceof String && "value".equalsIgnoreCase((String)s)).as("Column label col1")
                .expectNextMatches(s -> s instanceof String && "value".equalsIgnoreCase((String)s)).as("Column label col1 (get by uppercase)")
                .expectNext(true).as("getColumnNames.contains(value)")
                .expectNext(true).as("getColumnNames.contains(VALUE)")
                .verifyComplete();
    }

    @Override
    public String doGetSql(TestStatement statement) {
        if (TestStatement.CREATE_TABLE_AUTOGENERATED_KEY.equals(statement)) {
            return "CREATE TABLE test ( id INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY,  value INTEGER )";
        } else if (TestStatement.INSERT_VALUE_AUTOGENERATED_KEY.equals(statement)) {
            return "INSERT INTO test (value) VALUES(100)";
        } else {
            return TestKit.super.doGetSql(statement);
        }
    }
    /*
     * The Vert.X driver doesn't support LOB's:
     * https://github.com/eclipse-vertx/vertx-sql-client/issues/496
     * But we can still interact with a LOB table if we put some CAST statements in the SQL. This driver wrapper has the
     * necessary converters in place to handle the R2DBC Blob/Clob Java types as long as we can keep the underlying
     * Vert.X driver from choking on them.
     */
    @Override @Test
    public void blobInsert() {
        // https://github.com/eclipse-vertx/vertx-sql-client/blob/4.2.1/vertx-db2-client/src/main/java/io/vertx/db2client/impl/drda/DRDAQueryRequest.java#L1306
        //TestKit.super.clobInsert();
        Flux.usingWhen(getConnectionFactory().create(),
                connection -> {
                    // Add a CAST in the SQL so that the Vert.X driver doesn't try to send the param as a BLOB (even though the table column is)
                    Statement statement = connection.createStatement(expand(TestStatement.INSERT_BLOB_VALUE_PLACEHOLDER, "CAST(? AS VARBINARY)"));
                    statement.bind(0, Blob.from(Mono.just(StandardCharsets.UTF_8.encode("test-value"))));
                    return Flux.from(statement.execute())
                            .flatMap(this::extractRowsUpdated);
                },
                Connection::close)
                .as(StepVerifier::create)
                .expectNextCount(1).as("rows inserted")
                .verifyComplete();
    }

    @Override @Test
    public void blobSelect() {
        getJdbcOperations().execute(expand(TestStatement.INSERT_BLOB_VALUE_PLACEHOLDER, "?"), new AbstractLobCreatingPreparedStatementCallback(new DefaultLobHandler()) {
            @Override
            protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
                lobCreator.setBlobAsBytes(ps, 1, StandardCharsets.UTF_8.encode("test-value").array());
            }
        });

        // BLOB as ByteBuffer
        Flux.usingWhen(getConnectionFactory().create(),
                connection -> Flux.from(connection
                        .createStatement(expand(TestStatement.SELECT_BLOB_VALUE)
                                // Add a CAST in the SQL so that the Vert.X driver doesn't have to try to parse BLOB data in the row (currently causes NPE)
                                .replace("value", "CAST(value AS VARBINARY) AS value"))
                        .execute())
                        .flatMap(result -> result
                                .map((row, rowMetadata) -> extractColumn(row)))
                        .cast(ByteBuffer.class)
                        .map(buffer -> {
                            byte[] bytes = new byte[buffer.remaining()];
                            buffer.get(bytes);
                            return bytes;
                        }),
                Connection::close)
                .as(StepVerifier::create)
                .expectNextMatches(actual -> {
                    ByteBuffer expected = StandardCharsets.UTF_8.encode("test-value");
                    return Arrays.equals(expected.array(), actual);
                })
                .verifyComplete();

        // BLOB as Blob
        Flux.usingWhen(getConnectionFactory().create(),
                connection -> Flux.from(connection
                        .createStatement(expand(TestStatement.SELECT_BLOB_VALUE)
                                        // Add a CAST in the SQL so that the Vert.X driver doesn't have to try to parse BLOB data in the row (currently causes NPE)
                                        .replace("value", "CAST(value AS VARBINARY) AS value"))
                        .execute())
                        .flatMap(result -> Flux.usingWhen(result
                                        .map((row, rowMetadata) -> extractColumn(row, Blob.class)),
                                blob -> Flux.from(blob.stream()).reduce(ByteBuffer::put),
                                Blob::discard)),
                Connection::close)
                .as(StepVerifier::create)
                .expectNextMatches(actual -> {
                    ByteBuffer expected = StandardCharsets.UTF_8.encode("test-value");
                    return Arrays.equals(expected.array(), actual.array());
                })
                .verifyComplete();
    }


    @Override @Test
    public void clobInsert() {
        // https://github.com/eclipse-vertx/vertx-sql-client/blob/4.2.1/vertx-db2-client/src/main/java/io/vertx/db2client/impl/drda/DRDAQueryRequest.java#L1343
        //TestKit.super.clobInsert();
        Flux.usingWhen(getConnectionFactory().create(),
                connection -> {
                    // Add a CAST in the SQL so that the Vert.X driver doesn't try to send the param as a CLOB (even though the table column is)
                    Statement statement = connection.createStatement(expand(TestStatement.INSERT_CLOB_VALUE_PLACEHOLDER, "CAST(? AS VARCHAR)"));
                    statement.bind(0, Clob.from(Mono.just("test-value")));
                    return Flux.from(statement.execute())
                            .flatMap(Result::getRowsUpdated);
                },
                Connection::close)
                .as(StepVerifier::create)
                .expectNextCount(1).as("rows inserted")
                .verifyComplete();
    }

    @Override @Test
    public void clobSelect() {
        getJdbcOperations().execute(expand(TestStatement.INSERT_CLOB_VALUE_PLACEHOLDER, "?"), new AbstractLobCreatingPreparedStatementCallback(new DefaultLobHandler()) {
            @Override
            protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
                lobCreator.setClobAsString(ps, 1, "test-value");
            }
        });

        // CLOB defaults to String
        Flux.usingWhen(getConnectionFactory().create(),
                connection -> Flux.from(connection
                        .createStatement(expand(TestStatement.SELECT_CLOB_VALUE)
                                // Add a CAST in the SQL so that the Vert.X driver doesn't have to try to parse CLOB data in the row (currently causes NPE)
                                .replace("value", "CAST(value AS VARCHAR) AS value"))
                        .execute())
                        .flatMap(result -> result
                                .map((row, rowMetadata) -> extractColumn(row))),
                Connection::close)
                .as(StepVerifier::create)
                .expectNext("test-value").as("value from select")
                .verifyComplete();

        // CLOB consume as Clob
        Flux.usingWhen(getConnectionFactory().create(),
                connection -> Flux.from(connection
                        .createStatement(expand(TestStatement.SELECT_CLOB_VALUE)
                                // Add a CAST in the SQL so that the Vert.X driver doesn't have to try to parse CLOB data in the row (currently causes NPE)
                                .replace("value", "CAST(value AS VARCHAR) AS value"))
                        .execute())
                        .flatMap(result -> Flux.usingWhen(result
                                        .map((row, rowMetadata) -> extractColumn(row, Clob.class)),
                                clob -> Flux.from(clob.stream())
                                        .reduce(new StringBuilder(), StringBuilder::append)
                                        .map(StringBuilder::toString),
                                Clob::discard)),
                Connection::close)
                .as(StepVerifier::create)
                .expectNext("test-value").as("value from select")
                .verifyComplete();
    }
}
